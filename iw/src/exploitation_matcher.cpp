#include <iw/exploitation_matcher.hpp>

using namespace iw;

ExploitationMatcher::ExploitationMatcher(
    ros::NodeHandle& n, ros::NodeHandle& np)
{
    sub_intention_ = n.subscribe("intention", 10, 
            &ExploitationMatcher::intentionCB, this);
    sub_priority_ = np.subscribe("priority", 10, 
            &ExploitationMatcher::priorityCB, this);
    pub_desire_ = 
        np.advertise<std_msgs::String>("exploited_desire", 10);
    srv_register_ = 
        np.advertiseService("register_em", &ExploitationMatcher::registerCB, this);

}

void ExploitationMatcher::intentionCB(const hbba_msgs::Intention::ConstPtr& msg)
{
    // Flush the current desire map and rebuild it from scratch.
    // Skip empty desires.
    desire_map_.clear();

    assert(msg->desires.size() == msg->desire_types.size());
    for (size_t i = 0; i < msg->desires.size(); ++i)
    {
        const std::string& d_id = msg->desires[i];
        const std::string& d_t = msg->desire_types[i];
        if (d_id != "" && d_t != "")
        {
            DesireMapType::iterator dv = desire_map_.find(d_t);
            if (dv == desire_map_.end())
                dv = desire_map_.insert(
                    std::make_pair(d_t, StringVector())).first;
            dv->second.push_back(d_id);
        }

    }
}

void ExploitationMatcher::priorityCB(const std_msgs::Int32::ConstPtr& msg)
{
    // Find if any desire classes can be matched to the incoming
    // priority value.
    // Then, for each class found, find if any desires in the latest
    // intention are currently associated with it.
    // Publish an exploitation match for each of them, or warn the user.

    int priority = msg->data;
    if (priority_map_.find(priority) == priority_map_.end())
    {
        ROS_ERROR("Unknown priority value: %i", priority);
        return;
    }

    const StringVector& list = priority_map_[priority];
    typedef StringVector::const_iterator ItType;
    for (ItType i = list.begin(); i != list.end(); i++)
    {
        ROS_DEBUG("Exploitation for desire type %s.", i->c_str());
        DesireMapType::const_iterator d = desire_map_.find(*i); 
        if (d == desire_map_.end())
        {
            // This is totally normal for priorities than can fulfill
            // two different desires:
            //ROS_WARN("Desire type %s can't be matched to "
            //    "a current desire", i->c_str());
            continue;
        }
        for (ItType j = d->second.begin(); j != d->second.end(); ++j)
        {
            std_msgs::String msg;
            msg.data = *j;
            pub_desire_.publish(msg);
        }

    }

}

bool ExploitationMatcher::registerCB(
    hbba_msgs::RegisterExploitationMatch::Request& req,
    hbba_msgs::RegisterExploitationMatch::Response& rep)
{
    registerMatches(req.priority, req.classes);
    return true;
}

void ExploitationMatcher::registerMatches(
    const hbba_msgs::ExploitationMatch& matches)
{
    registerMatches(matches.priority, matches.classes);
}

void ExploitationMatcher::registerMatches(
    int priority, const StringVector& classes)
{
    if (priority_map_.find(priority) == priority_map_.end())
        priority_map_[priority] = StringVector();

    StringVector& list = priority_map_[priority];
    list.reserve(list.size() + classes.size());
    list.insert(list.end(), classes.begin(), classes.end());
}

